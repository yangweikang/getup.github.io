#### 私有作用域:
一个函数执行形成一个私有作用域，一个函数可以执行多次，每一次都会形成一个私有作用域，每个作用域都没有关系。
函数创建在堆内存中，函数运行在栈内存中。

#### 闭包:
一个私有作用域保护里面的，私有变量不受外界干扰
#### 私有变量：
1.在私有作用域下声明过的变量:使用var function let const

2.形参

####  函数的执行过程:
1.形成私有作用域-->
2.变量提升-->
3.给形参赋值-->
4.执行代码

```js
var a=10;
function fn(c){
    var a=1;
}
fn(2);
console.log(a,c);
```
```bash
在私有作用域下遇到变量了，先看是不是自己都私有变量，如果是就使用自己的私有变量，如果不是，就往上一级找，如果没有就没有继续找一直找到全局作用域为止，还找不到就报错了，这个查找的过程就叫作用域链。
```

#### 内存 :
堆内存:存储引用数据类型

栈内存:作用域

#### 堆内存释放：
当某个堆内存的地址不再被变量占用，此时浏览器会在空闲的时候将其销毁
注意：以后开发中后期不再使用的引用数据类型手动将其赋值为null null为空指针


```js
var ary=[1];
ary=[2];//ary重新指向[2] ,原存储[1]将在浏览器空闲时释放

obj={a:1,b:2,c:3};
obj=null;//obj指向null ,obj将在浏览器空闲时释放
```
不存在覆盖，将有两个地址，当前地址不再被变量占用此时浏览器会在空闲的时候将其销毁


####  栈内存的释放：
全局作用域：当关闭浏览器的时候全局作用域销毁
私有作用域 
销毁 一个作用域没有被外界占用的内容，此时就销毁
不销毁 当一个私有作用域返回一个地址被外界占用了，此时这个作用域就不销毁

##### 销毁
```js
function fn(){
  a=1;
}
fn()
```
##### 不销毁，内存泄露
```js
function ff(){
  var a=1；
  return function fn(){
     console.log(a)
  }
}
var F=ff();
F();
```
